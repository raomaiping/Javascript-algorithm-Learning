## 栈是什么？
栈是一种遵从 **后进先出(LIFO)** 原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫做栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。

## 使用数组去模拟栈
<<< @/../vuepress-starter/js/1.创建一个基于数组的栈.js#example

### 测试
<<< @/../vuepress-starter/js/1.创建一个基于数组的栈.js#test

## 使用对象去模拟栈
<<< @/../vuepress-starter/js/2.创建一个基于对象的栈.js#example

::: tip
在基于数组的版本中，我们可以同时向 **Stack** 类中添加多个元素。由于现在使用了一个对象，这个版本的 **push** 方法只允许我们一次插入一个元素。

而且，在数组版本中，我们不需要关心 **toString** 方法的实现，
因为数据结构可以使用数组已经提供的 **toString** 方法。对于使用对象的版本，我们将创建一个 **toString** 方法来像数组一样打印栈的内容。
:::

### 测试
<<< @/../vuepress-starter/js/2.创建一个基于对象的栈.js#test

## 如何保护数据结构内部元素？
在创建别的开发者也可以使用的数据结构或对象时，我们希望保护内部的元素，只有我们暴露出的方法才能修改内部结构。
对于 **Stack** 类来说，要确保元素只会被添加到栈顶，而不是栈底或其他任意位置（比如栈的中间）。不幸的是，我们在 **Stack** 类中声明的 **items** 和 **count** 属性并没有得到保护，因为 **JavaScript** 的类就是这样工作的。

试着执行下面的代码
```js
const stack = new Stack(); 
console.log(Object.getOwnPropertyNames(stack)); 
console.log(Object.keys(stack)); 
console.log(stack.items); 
```

行 {2} 和行 {3} 的输出结果是 ["count","items"] 。这表示 **count** 和 **items** 属性是公开的，我们可以像行 {4} 那样直接访问它们。根据这种行为，我们可以对这二个属性赋新的值。

::: tip
在本例中，我们希望 **Stack** 类的用户只能访问我们在类中暴露的方法。下面来看看其他使用 **JavaScript** 来实现私有属性的方法。 
:::

### 下划线命名约定

一部分开发者喜欢在 **JavaScript** 中使用下划线命名约定来标记一个属性为私有属性。

```js{3-4}
class Stack { 
  constructor() { 
    this._count = 0; 
    this._items = {}; 
  } 
}
```
下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识。

### 用 ES6 的限定作用域 **Symbol** 实现类
ES6新增了一种叫作 **Symbol** 的基本类型，它是不可变的，可以用作对象的属性。看看怎么样它在 **Stack** 类中声明 **items** 属性（我们将使用数组来存储元素以简化代码）。

```js{1,4}
const _items = Symbol('stackItems'); // {1} 
class Stack { 
   constructor () { 
     this[_items] = []; // {2} 
   } 
   // 栈的方法
}
```
在上面的代码中，我们声明了 **Symbol** 类型的变量 **_items** （行{1}）, 在类的 **constructor** 函数中初始化它的值（行{2}）。要访问 **_items** , 只需要把所有的 **this.items** 都换成 **this[_items]** 。

这种方法创建了一个假的私有属性，因为ES6新增的 **Object.getOwnProperty-Symbols**
方法能够取到类里面声明的所有 **Symbols** 属性。下面是一个破坏 **Stack** 类的例子。

```js
const stack = new Stack(); 
stack.push(5); 
stack.push(8); 
let objectSymbols = Object.getOwnPropertySymbols(stack); 
console.log(objectSymbols.length); // 输出 1 
console.log(objectSymbols); // [Symbol()] 
console.log(objectSymbols[0]); // Symbol() 
stack[objectSymbols[0]].push(1); 
stack.print(); // 输出 5, 8, 1
```

从以上代码可以看到，访问 **stack[objectSymbols[0]]** 是可以得到 **_items** 的。并且，
**_items** 属性是一个数组，可以进行任意的数组操作，比如从中间删除或添加元素（使用对象进
行存储也是一样的）。但我们操作的是栈，不应该出现这种行为。

### 用ES6的WeakMap实现类

有一种数据类型可以确保属性是私有的，这就是 **WeakMap** 。我们会在后面深入探讨Map这种数据结构， 现在只需要知道 **WeakMap** 可以存储键值对，其中键是对象，值可以是任意数据类型。

如果用 **WeakMap** 来存储 **items** 属性（数组版本）， **Stack** 类就是这样的：

```js{1,4,7} 
const items = new WeakMap();
class Stack {
constructor() {
    items.set(this, []); 
}
push(element) {
    const s = items.get(this);
    s.push(element);
}
pop() {
    const s = items.get(this);
    const r = s.pop();
    return r;
}
// 其他方法
}
```

上面的代码片段解释如下:
* 行{1} ，声明一个 **WeakMap** 类型的变量 **items** 。
* 行{4} ，在 **constructor** 中，以 **this** （Stack 类自己的引用）为键，把代表栈的数组存入 **items** 。
* 行{7} ，从 **WeakMap** 中取出值，即以 **this** 为键（行{4}设置的）从 **items** 中取值。

::: tip
现在我们知道了， **items** 在Stack 类里是真正的私有属性。

采用这种方法，代码的可读性不强，而且在扩展类时无法继承私有属性。鱼和熊掌不可兼得！
:::

### ES 提案：私有类字段

```js
class Stack {
    #count = 0;
    #items = 0;
    // 栈的方法 ...
}
```
我们可以通过在属性前添加井号（＃）作为前缀来声明私有属性。这种行为和WeakMap 中的私有属性很相似。所以在不远的未来，我们有希望不使用特殊技巧或牺牲代码可读性，就能使用私有类属性。

## 栈的应用场景
::: tip
栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后面讨论图和回溯问题时，我们会学习如何应用这个例子）。
:::

### 场景一、 十进制转二进制

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f2129fb7dd46938ef7349380825849~tplv-k3u1fbpfcp-watermark.image?)

对于35这样的十进制数字来说，如果你想把它转为二进制，那么你需要这样来操作，首先对35来说你要除上一个2，得到17和一个余数1，然后对17除上一个2，得到8和余数1，以此类推。

把得到的所有余数记录下来倒序输出，得到的100011就是35转换成二进制的结果。我们发现后出来的余数反而排在前面，这个不就是后进先出吗？

既然有后进先出的规律那我们就可以用栈这个数据结构来做这个算法。把余数依次的入栈在把余数依次的出栈，那我们不就实现余数的倒序输出吗？

下面是对应的算法描述。

<<< @/../vuepress-starter/js/3.使用自定义栈实现进制转换.js#example{7-12}

在这段代码里，当除法的结果不为0 时（行{7}），我们会获得一个余数，并放到栈里（行{8} 、行{9}）。然后让结果继续除以2 （行{10}）。

另外请注意： JavaScript 有数值类型，但是它不会区分整数和浮点数。因此，要使用Math. floor 函数仅返回除法运算结果的整数部分。

最后，用pop 方法把栈中的元素都移除，把出栈的元素连接成字符串（行{12}）。

用刚才写的算法做一些测试，使用以下代码把结果输出到控制台里。

<<< @/../vuepress-starter/js/3.使用自定义栈实现进制转换.js#test

#### 进制转换算法
我们可以修改之前的算法，使之能把十进制转换成基数为2 ~ 36 的任意进制。除了把十进制数除以2 转成二进制数，还可以传入其他任意进制的基数为参数，就像下面的算法这样。 

<<< @/../vuepress-starter/js/3.使用自定义栈实现进制转换.js#example1{4,18}

我们只需要改变一个地方。

在将十进制转成二进制时，余数是0 或1; 在将十进制转成八进制时，余数是0~7 ；但是将十进制转成十六进制时，余数是0~9 加上A 、B 、C, D 、E 和F （对应10 、11 、12 、13 、14 和15）。

因此，我们需要对栈中的数字做个转化才可以（行{4} 和行{18}） 。因此，从十一进制开始，字母表中的每个字母将表示相应的基数。字母A 代表基数11, B 代表基数12, 以此类推。

可以使用之前的算法，输出结果如下。

<<< @/../vuepress-starter/js/3.使用自定义栈实现进制转换.js#test1

### 场景二、 有效的括号

![1639194192474_C313B84D-4B45-49b0-8029-A87937DBB039.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6edde62942f04c95a2e4ac0ff6313d45~tplv-k3u1fbpfcp-watermark.image?)

通过观察上述的括号，我们可以得出一个规律：

* 越靠后的左括号，对应的右括号越靠前。
* 左括号入栈，右括号出栈，栈空了就是合法的。

根据上述规律我们总结之后，可以得出如下算法：

<<< @/../vuepress-starter/js/4.使用自定义栈解决有效的括号.js#example{2,14,16,20}

* 对传入的字符做一个判断，如果他的字符长度为0，那肯定不是有效的括号（行{2}），直接返回 ***false*** 就好了。

* 对传入的字符串进行一个迭代，如果在迭代的过程中碰到了左括号，我们进行一个入栈操作（行{14}），如果迭代的过程中没有碰到左括号且栈内没有元素，说明传入的字符串第一个字符肯定不是左括号，所以也就不是有效的括号，我们给他设置 ***false***（行{16}）。

* 我们在接着继续迭代，肯定是出现是否是右括号的情况，我们弹出一个左括号（栈顶元素），拿着它在左括号列表中出现的位置去和当前元素在右括号列表出现的位置，借此来判断是否是同一种括号，如果不是我们同样给他设置 ***false***（行{20}）。

场景三、 函数的调用堆栈

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8910284757364b98a68ab71a121d0e56~tplv-k3u1fbpfcp-watermark.image?)

通过观察上述函数我们发现：

* 最后调用的函数，最先执行完。
* js解释器使用栈来控制函数的调用顺序。